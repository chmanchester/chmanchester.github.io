<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">chmanchester's blog: chmanchester's blog</title>
 <link rel="self" href="http://chmanchester.github.io/feeds/all.atom.xml" />
 <link href="http://chmanchester.github.io/index.html" />
 <id>urn:http-chmanchester-github-io:-index-html</id>
 <updated>2015-07-27T01:41:38Z</updated>
 <entry>
  <title type="text">Introducing mach try</title>
  <link rel="alternate" href="http://chmanchester.github.io/blog/2015/07/26/introducing-mach-try/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-chmanchester-github-io:-blog-2015-07-26-introducing-mach-try</id>
  <published>2015-07-27T01:41:38Z</published>
  <updated>2015-07-27T01:41:38Z</updated>
  <author>
   <name>Chris</name></author>
  <content type="html">&lt;html&gt;
&lt;p&gt;This is a short introduction to mach try, a mach command that simplifies the process of selecting tests and pushing them to the try server.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;To follow along at home you&amp;rsquo;ll either need to be using git cinnabar or have a modern mercurial and the hg &amp;ldquo;push-to-try&amp;rdquo; extension (available from |mach mercurial-setup|). Append &amp;mdash;no-push to commands to keep them from pushing to the try server, and -n to see verbose messages associated with the results of commands.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mach try is a command that takes try syntax and automates the steps
# to push the current tree to try with that syntax.
# For instance:

$ ./mach try -p win32 -u mochitest-bc

# ... will result in pushing "try: -b do -p win32 -u mochitest-bc -t none"
# to try. This saves dealing with mq or other ways of generating the try
# message commit. (An in-memory commit is generated with the appropriate
# message -- mq is not invoked at any stage).

# The more novel feature exposed by mach try is the ability to select
# specific test directories containing xpcshell, mochitests or reftests
# to run on the try server.

# For instance, if I've just made a change to one of the python libraries
# used by our test harnesses, and I'd like to quickly check that this
# feature works on windows. I can run:

$ ./mach try -p win64 testing/xpcshell testing/mochitest/tests

# This will result in the small number of xpcshell and mochitest tests
# that live next to their harnesses being run (in a single chunk) on
# try, so I can get my results without waiting for the entire suite,
# and I don't need to sift through logs to figure out which chunk a
# test lives in when I only care about running certain tests.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more details run ./mach help try. As the command will inform you, this feature is under development &amp;mdash; bugs should be filed blocking &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1149670"&gt;bug 1149670&lt;/a&gt;).&lt;/p&gt;&lt;/html&gt;</content></entry>
 <entry>
  <title type="text">Automatic triggering on try server</title>
  <link rel="alternate" href="http://chmanchester.github.io/blog/2015/07/15/automatic-triggering-on-try-server/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-chmanchester-github-io:-blog-2015-07-15-automatic-triggering-on-try-server</id>
  <published>2015-07-15T21:44:13Z</published>
  <updated>2015-07-15T21:44:13Z</updated>
  <author>
   <name>Chris</name></author>
  <content type="html">&lt;html&gt;
&lt;p&gt;If you&amp;rsquo;ve pushed to Mozilla&amp;rsquo;s try server recently, you&amp;rsquo;ve probably noticed some of your failures being re-triggered automatically. This happens courtesy of the &lt;a href="https://github.com/chmanchester/trigger-bot"&gt;trigger bot&lt;/a&gt; tool implemented as a pulse listener that invokes self-serve in response to certain events.&lt;/p&gt;

&lt;p&gt;Two trigerring rules are currently implemented:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;When a test fails it&amp;rsquo;s triggered one more time, up to a certain portion of all  jobs for the push.&lt;/li&gt;
 &lt;li&gt;When &lt;code&gt;--rebuild&lt;/code&gt; is found in try syntax, all test jobs for that push are  triggered the specified number of times.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Finally, if &lt;code&gt;--rebuild&lt;/code&gt; is specified, nothing gets triggered when a test fails, and if &lt;code&gt;--no-retry&lt;/code&gt; is found in try syntax, no triggering happens for the push.&lt;/p&gt;

&lt;p&gt;This was enabled at the end of June, and I&amp;rsquo;ve gotten a bit of feedback (almost mostly positive). My own curiosity is about the overall volume of these jobs, so I pulled some stats from self-serve to see how much we&amp;rsquo;ve ended up triggering. For the first 2 weeks of July, there were &lt;strong&gt;373,772&lt;/strong&gt; jobs on try, &lt;strong&gt;13,099&lt;/strong&gt; of which were initiated by the trigger-bot (&lt;strong&gt;3.5%&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;This is a larger proportion than I think it should be, but we&amp;rsquo;ve recently landed changes that mean we will trigger fewer hidden jobs. Hidden jobs are usually hidden due to failing persistently, so this should reduce overall triggering.&lt;/p&gt;

&lt;p&gt;The rudimentary script I used to gather these stats is available on the &lt;a href="https://github.com/chmanchester/trigger-bot/commit/845bdf3737b5c4bff2a38c45311f71c96ec450dc"&gt;trigger-bot repo&lt;/a&gt;&lt;/p&gt;
&lt;!-- more--&gt;&lt;/html&gt;</content></entry>
 <entry>
  <title type="text">Content to begin after this post</title>
  <link rel="alternate" href="http://chmanchester.github.io/blog/2015/05/02/content-to-begin-after-this-post/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-chmanchester-github-io:-blog-2015-05-02-content-to-begin-after-this-post</id>
  <published>2015-05-03T02:21:15Z</published>
  <updated>2015-05-03T02:21:15Z</updated>
  <author>
   <name>Chris</name></author>
  <content type="html">&lt;html&gt;
&lt;p&gt;This is a short post to get things up and running and understand markdown.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;I’ve been an employee at the Mozilla Corporation working on test infrastructure and tools for about a year. In summer of 2013 I was an intern at the same, and before that a contributor.&lt;/p&gt;

&lt;p&gt;In the intervening months I attended the University of Pennsylvania, where I was assigned reading such as &lt;a href="http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html"&gt;Why Functional Programming Matters&lt;/a&gt;, and formed some opinions on the subject. In retrospect I think my primary attraction to languages like Haskell was that I found it easy to write correct and powerful programs in them, and this was a lot of fun. More recently I’ve come to believe I was not measuring my experience by the most important criteria, although just the other day I was suffering from a lack of concatMap in python. (Due to duck typing, &lt;code&gt;sum([[1], [2, 3]], [])&lt;/code&gt; is &lt;code&gt;[1, 2, 3]&lt;/code&gt;, conveniently).&lt;/p&gt;

&lt;p&gt;These days my favorite functional programming language is JavaScript&lt;sup&gt;&lt;a href="#2015-05-02-content-to-begin-after-this-post-footnote-1-definition" name="2015-05-02-content-to-begin-after-this-post-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2015-05-02-content-to-begin-after-this-post-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;I tend to agree &lt;a href="http://cs.brown.edu/~sk/Publications/Papers/Published/sk-teach-pl-post-linnaean/paper.pdf"&gt;programming paradigms are on their way out&lt;/a&gt;.&amp;nbsp;&lt;a href="#2015-05-02-content-to-begin-after-this-post-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/html&gt;</content></entry></feed>